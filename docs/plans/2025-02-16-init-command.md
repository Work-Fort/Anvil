# Init Command Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build `anvil init` command that sets up a kernel release/signing repository with a 5-step tabbed wizard and non-interactive mode.

**Architecture:** Composable Bubble Tea tab components with parent orchestrator. Each tab implements a common interface and manages its own state. Atomic file generation with rollback on failure.

**Tech Stack:** Cobra (CLI), Bubble Tea (TUI), Huh (forms), Lipgloss (styling), Viper (config)

---

## Task 1: Project Structure & Shared Types

**Files:**
- Create: `cmd/init/messages.go`
- Create: `pkg/init/types.go`

**Step 1: Write test for shared types**

Create: `pkg/init/types_test.go`
```go
// SPDX-License-Identifier: Apache-2.0
package init_test

import (
	"testing"

	initpkg "github.com/Work-Fort/Anvil/pkg/init"
)

func TestInitSettings_DefaultValues(t *testing.T) {
	settings := initpkg.InitSettings{}

	// Initially empty
	if settings.KeyName != "" {
		t.Errorf("expected empty KeyName, got %s", settings.KeyName)
	}

	if settings.ConfigX86Path != "" {
		t.Errorf("expected empty ConfigX86Path, got %s", settings.ConfigX86Path)
	}
}

func TestInitSettings_SetValues(t *testing.T) {
	settings := initpkg.InitSettings{
		KeyName:           "Test Kernels",
		KeyEmail:          "test@example.com",
		KeyExpiry:         "1y",
		KeyFormat:         "armored",
		HistoryFormat:     "binary",
		ConfigX86Path:     "configs/kernel-x86_64.config",
		ConfigAarch64Path: "configs/kernel-aarch64.config",
	}

	if settings.KeyName != "Test Kernels" {
		t.Errorf("KeyName = %s, want Test Kernels", settings.KeyName)
	}

	if settings.KeyFormat != "armored" {
		t.Errorf("KeyFormat = %s, want armored", settings.KeyFormat)
	}

	if settings.HistoryFormat != "binary" {
		t.Errorf("HistoryFormat = %s, want binary", settings.HistoryFormat)
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./pkg/init/... -v`
Expected: FAIL with "no such file or directory"

**Step 3: Create shared types**

Create: `pkg/init/types.go`
```go
// SPDX-License-Identifier: Apache-2.0
package init

// InitSettings holds all collected settings across wizard tabs
type InitSettings struct {
	// Tab 2: Kernel Configs (paths)
	ConfigX86Path     string
	ConfigAarch64Path string

	// Tab 3: Signing Settings
	KeyName       string
	KeyEmail      string
	KeyExpiry     string
	KeyFormat     string // "armored" or "binary"
	HistoryFormat string // "armored" or "binary"

	// Tab 4: Key Generation (results)
	KeyGenerated  bool
	KeyPath       string
	PublicKeyPath string

	// Tab 5: File Generation (results)
	FilesCreated []string
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./pkg/init/... -v`
Expected: PASS

**Step 5: Create message types**

Create: `cmd/init/messages.go`
```go
// SPDX-License-Identifier: Apache-2.0
package init

import (
	initpkg "github.com/Work-Fort/Anvil/pkg/init"
)

// TabCompleteMsg signals a tab has completed
type TabCompleteMsg struct {
	TabIndex int
}

// SettingsUpdateMsg carries settings from a tab to parent
type SettingsUpdateMsg struct {
	Settings initpkg.InitSettings
}

// TabErrorMsg carries error from a tab to parent
type TabErrorMsg struct {
	TabIndex int
	Error    error
}

// GenerationCompleteMsg signals file generation finished
type GenerationCompleteMsg struct {
	FilesCreated []string
	Error        error
}
```

**Step 6: Commit**

```bash
mkdir -p cmd/init pkg/init
git add cmd/init/messages.go pkg/init/types.go pkg/init/types_test.go
git commit -m "feat(init): add shared types and messages"
```

---

## Task 2: Config Templates

**Files:**
- Create: `cmd/init/templates.go`
- Create: `cmd/init/templates_test.go`

**Step 1: Write template tests**

Create: `cmd/init/templates_test.go`
```go
// SPDX-License-Identifier: Apache-2.0
package init

import (
	"strings"
	"testing"
)

func TestGetX86ConfigTemplate(t *testing.T) {
	tmpl := getX86ConfigTemplate()

	// Verify header
	if !strings.Contains(tmpl, "# Generated by anvil init") {
		t.Error("expected header comment")
	}

	// Verify architecture
	if !strings.Contains(tmpl, "x86_64") {
		t.Error("expected x86_64 architecture")
	}

	// Verify TODO marker
	if !strings.Contains(tmpl, "TODO: Update this template") {
		t.Error("expected TODO comment")
	}

	// Verify essential options mentioned
	if !strings.Contains(tmpl, "CONFIG_KVM_GUEST") {
		t.Error("expected CONFIG_KVM_GUEST mention")
	}
	if !strings.Contains(tmpl, "CONFIG_VIRTIO") {
		t.Error("expected CONFIG_VIRTIO mention")
	}
}

func TestGetAarch64ConfigTemplate(t *testing.T) {
	tmpl := getAarch64ConfigTemplate()

	if !strings.Contains(tmpl, "aarch64") {
		t.Error("expected aarch64 architecture")
	}

	if !strings.Contains(tmpl, "# Generated by anvil init") {
		t.Error("expected header comment")
	}

	if !strings.Contains(tmpl, "TODO: Update this template") {
		t.Error("expected TODO comment")
	}
}

func TestGetGitignoreTemplate(t *testing.T) {
	tmpl := getGitignoreTemplate()

	// Verify build artifacts
	if !strings.Contains(tmpl, "build/") {
		t.Error("expected build/ in gitignore")
	}

	if !strings.Contains(tmpl, "vmlinux*") {
		t.Error("expected vmlinux* in gitignore")
	}

	if !strings.Contains(tmpl, "archive/") {
		t.Error("expected archive/ in gitignore")
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./cmd/init/... -v`
Expected: FAIL with "undefined: getX86ConfigTemplate"

**Step 3: Implement templates**

Create: `cmd/init/templates.go`
```go
// SPDX-License-Identifier: Apache-2.0
package init

// getX86ConfigTemplate returns the minimal x86_64 kernel config template
func getX86ConfigTemplate() string {
	return `# Generated by anvil init
# Minimal Firecracker kernel configuration for x86_64
#
# Customize these settings for your use case.
# Essential Firecracker options:
#   CONFIG_KVM_GUEST=y
#   CONFIG_VIRTIO=y
#   CONFIG_VIRTIO_BLK=y
#   CONFIG_VIRTIO_NET=y
#
# TODO: Update this template when documentation is available

# Add your CONFIG_* options below:
`
}

// getAarch64ConfigTemplate returns the minimal aarch64 kernel config template
func getAarch64ConfigTemplate() string {
	return `# Generated by anvil init
# Minimal Firecracker kernel configuration for aarch64
#
# Customize these settings for your use case.
# Essential Firecracker options:
#   CONFIG_KVM_GUEST=y
#   CONFIG_VIRTIO=y
#   CONFIG_VIRTIO_BLK=y
#   CONFIG_VIRTIO_NET=y
#
# TODO: Update this template when documentation is available

# Add your CONFIG_* options below:
`
}

// getGitignoreTemplate returns the .gitignore content for kernel repos
func getGitignoreTemplate() string {
	return `# Kernel build artifacts
build/
vmlinux*
Image*
*.tar.xz
*.tar.gz

# Local archives
archive/
`
}

// getRepoConfigTemplate returns the anvil.yaml template
func getRepoConfigTemplate() string {
	return `# Generated by anvil init
kernels:
  config:
    x86_64: {{.ConfigX86Path}}
    aarch64: {{.ConfigAarch64Path}}

signing:
  key:
    name: "{{.KeyName}}"
    email: "{{.KeyEmail}}"
    expiry: "{{.KeyExpiry}}"
    format: "{{.KeyFormat}}"
    location: keys
  history:
    location: keys/history
    format: "{{.HistoryFormat}}"
  encrypted-keys: true
`
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./cmd/init/... -v`
Expected: PASS

**Step 5: Commit**

```bash
git add cmd/init/templates.go cmd/init/templates_test.go
git commit -m "feat(init): add config and gitignore templates"
```

---

## Task 3: File Generator

**Files:**
- Create: `pkg/init/generator.go`
- Create: `pkg/init/generator_test.go`

**Step 1: Write generator tests**

Create: `pkg/init/generator_test.go`
```go
// SPDX-License-Identifier: Apache-2.0
package init_test

import (
	"os"
	"path/filepath"
	"testing"

	initpkg "github.com/Work-Fort/Anvil/pkg/init"
)

func TestGenerateRepoFiles_Success(t *testing.T) {
	// Create temp directory
	tmpDir := t.TempDir()
	origDir, _ := os.Getwd()
	defer os.Chdir(origDir)
	os.Chdir(tmpDir)

	settings := initpkg.InitSettings{
		ConfigX86Path:     "configs/kernel-x86_64.config",
		ConfigAarch64Path: "configs/kernel-aarch64.config",
		KeyName:           "Test Kernels",
		KeyEmail:          "test@example.com",
		KeyExpiry:         "1y",
		KeyFormat:         "armored",
		HistoryFormat:     "armored",
	}

	files, err := initpkg.GenerateRepoFiles(settings, getX86Template(), getAarch64Template())
	if err != nil {
		t.Fatalf("GenerateRepoFiles failed: %v", err)
	}

	// Verify directories created
	if _, err := os.Stat("configs"); os.IsNotExist(err) {
		t.Error("configs/ directory not created")
	}
	if _, err := os.Stat("keys"); os.IsNotExist(err) {
		t.Error("keys/ directory not created")
	}
	if _, err := os.Stat("keys/history"); os.IsNotExist(err) {
		t.Error("keys/history/ directory not created")
	}

	// Verify files created
	expectedFiles := []string{
		"anvil.yaml",
		".gitignore",
		"configs/kernel-x86_64.config",
		"configs/kernel-aarch64.config",
	}

	for _, file := range expectedFiles {
		if _, err := os.Stat(file); os.IsNotExist(err) {
			t.Errorf("file not created: %s", file)
		}
	}

	// Verify files list returned
	if len(files) < len(expectedFiles) {
		t.Errorf("files returned = %d, want at least %d", len(files), len(expectedFiles))
	}
}

func TestGenerateRepoFiles_AlreadyInitialized(t *testing.T) {
	tmpDir := t.TempDir()
	origDir, _ := os.Getwd()
	defer os.Chdir(origDir)
	os.Chdir(tmpDir)

	// Create existing config
	os.WriteFile("anvil.yaml", []byte("existing"), 0644)

	settings := initpkg.InitSettings{}
	_, err := initpkg.GenerateRepoFiles(settings, "", "")

	if err == nil {
		t.Error("expected error for already initialized directory")
	}
}

func TestGenerateRepoFiles_Rollback(t *testing.T) {
	// This test verifies rollback on failure
	// We'll simulate failure by using invalid permissions
	tmpDir := t.TempDir()
	origDir, _ := os.Getwd()
	defer os.Chdir(origDir)
	os.Chdir(tmpDir)

	// Create read-only directory that will cause write failure
	os.Mkdir("configs", 0444)

	settings := initpkg.InitSettings{
		ConfigX86Path: "configs/kernel-x86_64.config",
	}

	_, err := initpkg.GenerateRepoFiles(settings, "test", "test")
	if err == nil {
		t.Error("expected error when write fails")
	}

	// Verify configs directory was cleaned up (rollback)
	// Note: rollback removes directories it created
}

// Helper functions
func getX86Template() string {
	return "# x86_64 config"
}

func getAarch64Template() string {
	return "# aarch64 config"
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./pkg/init/... -run TestGenerateRepoFiles -v`
Expected: FAIL with "undefined: GenerateRepoFiles"

**Step 3: Implement generator**

Create: `pkg/init/generator.go`
```go
// SPDX-License-Identifier: Apache-2.0
package init

import (
	"bytes"
	"fmt"
	"os"
	"text/template"
)

const repoConfigTemplate = `# Generated by anvil init
kernels:
  config:
    x86_64: {{.ConfigX86Path}}
    aarch64: {{.ConfigAarch64Path}}

signing:
  key:
    name: "{{.KeyName}}"
    email: "{{.KeyEmail}}"
    expiry: "{{.KeyExpiry}}"
    format: "{{.KeyFormat}}"
    location: keys
  history:
    location: keys/history
    format: "{{.HistoryFormat}}"
  encrypted-keys: true
`

const gitignoreTemplate = `# Kernel build artifacts
build/
vmlinux*
Image*
*.tar.xz
*.tar.gz

# Local archives
archive/
`

// GenerateRepoFiles creates all repository files atomically
// Returns list of created files, or error with rollback
func GenerateRepoFiles(settings InitSettings, x86Template, aarch64Template string) ([]string, error) {
	var created []string

	// Validate not already initialized
	if err := validateNotInitialized(); err != nil {
		return nil, err
	}

	// Create directories
	dirs := []string{"configs", "keys", "keys/history"}
	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return created, rollback(created, fmt.Errorf("failed to create %s: %w", dir, err))
		}
		created = append(created, dir+"/")
	}

	// Render repo config template
	repoConfig, err := renderTemplate(repoConfigTemplate, settings)
	if err != nil {
		return created, rollback(created, fmt.Errorf("failed to render config: %w", err))
	}

	// Write files
	files := map[string]string{
		"anvil.yaml":          repoConfig,
		".gitignore":                   gitignoreTemplate,
		"configs/kernel-x86_64.config": x86Template,
		"configs/kernel-aarch64.config": aarch64Template,
	}

	for path, content := range files {
		if err := os.WriteFile(path, []byte(content), 0644); err != nil {
			return created, rollback(created, fmt.Errorf("failed to write %s: %w", path, err))
		}
		created = append(created, path)
	}

	return created, nil
}

// validateNotInitialized checks if directory is already initialized
func validateNotInitialized() error {
	if _, err := os.Stat("anvil.yaml"); err == nil {
		return fmt.Errorf("already initialized (anvil.yaml exists)")
	}
	return nil
}

// renderTemplate renders a Go template with settings
func renderTemplate(tmpl string, settings InitSettings) (string, error) {
	t, err := template.New("config").Parse(tmpl)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, settings); err != nil {
		return "", err
	}

	return buf.String(), nil
}

// rollback deletes created files/directories in reverse order
func rollback(created []string, originalErr error) error {
	for i := len(created) - 1; i >= 0; i-- {
		os.RemoveAll(created[i])
	}
	return fmt.Errorf("init failed, rolled back: %w", originalErr)
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./pkg/init/... -run TestGenerateRepoFiles -v`
Expected: PASS

**Step 5: Commit**

```bash
git add pkg/init/generator.go pkg/init/generator_test.go
git commit -m "feat(init): add atomic file generator with rollback"
```

---

## Task 4: Tab 1 - Welcome

**Files:**
- Create: `cmd/init/tab_welcome.go`

**Step 1: Implement welcome tab**

Create: `cmd/init/tab_welcome.go`
```go
// SPDX-License-Identifier: Apache-2.0
package init

import (
	"github.com/charmbracelet/bubbles/spinner"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/Work-Fort/Anvil/pkg/config"
	"github.com/Work-Fort/Anvil/pkg/ui"
)

// WelcomeTab shows initialization overview
type WelcomeTab struct {
	width   int
	height  int
	spinner spinner.Model
}

// NewWelcomeTab creates a new welcome tab
func NewWelcomeTab() *WelcomeTab {
	s := spinner.New()
	s.Spinner = spinner.Dot
	s.Style = lipgloss.NewStyle().Foreground(config.CurrentTheme.GetPrimaryColor())

	return &WelcomeTab{
		spinner: s,
	}
}

// Init implements tea.Model
func (t *WelcomeTab) Init() tea.Cmd {
	return t.spinner.Tick
}

// Update implements tea.Model
func (t *WelcomeTab) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		t.width = msg.Width
		t.height = msg.Height
		return t, nil

	case tea.KeyMsg:
		switch msg.String() {
		case "enter":
			// Signal completion
			return t, func() tea.Msg {
				return TabCompleteMsg{TabIndex: 0}
			}
		}

	case spinner.TickMsg:
		var cmd tea.Cmd
		t.spinner, cmd = t.spinner.Update(msg)
		return t, cmd
	}

	return t, nil
}

// View implements tea.Model
func (t *WelcomeTab) View() string {
	theme := config.CurrentTheme

	title := lipgloss.NewStyle().
		Bold(true).
		Foreground(theme.GetPrimaryColor()).
		Render("Initialize Kernel Release Repository")

	content := lipgloss.JoinVertical(
		lipgloss.Left,
		"",
		title,
		"",
		"This wizard will set up the current directory as a kernel release repository.",
		"",
		"What will be created:",
		theme.CompleteIndicator()+" anvil.yaml (repo configuration)",
		theme.CompleteIndicator()+" configs/ directory with minimal kernel templates",
		theme.CompleteIndicator()+" Encrypted signing keys",
		theme.CompleteIndicator()+" .gitignore for build artifacts",
		"",
		"",
		lipgloss.NewStyle().
			Foreground(theme.GetMutedColor()).
			Render("Press Enter to continue"),
	)

	return content
}

// IsComplete returns whether this tab is done
func (t *WelcomeTab) IsComplete() bool {
	return false // Completes on Enter key
}

// GetState returns tab state
func (t *WelcomeTab) GetState() ui.TabState {
	return ui.TabActive // Always active when shown
}
```

**Step 2: Commit**

```bash
git add cmd/init/tab_welcome.go
git commit -m "feat(init): add welcome tab"
```

---

## Task 5: Tab 2 - Config Generation

**Files:**
- Create: `cmd/init/tab_configs.go`

**Step 1: Implement configs tab**

Create: `cmd/init/tab_configs.go`
```go
// SPDX-License-Identifier: Apache-2.0
package init

import (
	"github.com/charmbracelet/bubbles/spinner"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/Work-Fort/Anvil/pkg/config"
	initpkg "github.com/Work-Fort/Anvil/pkg/init"
	"github.com/Work-Fort/Anvil/pkg/ui"
)

// ConfigsTab auto-generates kernel config templates
type ConfigsTab struct {
	width     int
	height    int
	spinner   spinner.Model
	generated bool
	err       error
}

// NewConfigsTab creates a new configs tab
func NewConfigsTab() *ConfigsTab {
	s := spinner.New()
	s.Spinner = spinner.Dot
	s.Style = lipgloss.NewStyle().Foreground(config.CurrentTheme.GetSecondaryColor())

	return &ConfigsTab{
		spinner: s,
	}
}

// Init implements tea.Model
func (t *ConfigsTab) Init() tea.Cmd {
	// Start generation immediately
	return tea.Batch(
		t.spinner.Tick,
		func() tea.Msg {
			return generateConfigsMsg{}
		},
	)
}

// generateConfigsMsg triggers config generation
type generateConfigsMsg struct{}

// configsGeneratedMsg signals generation complete
type configsGeneratedMsg struct {
	err error
}

// Update implements tea.Model
func (t *ConfigsTab) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		t.width = msg.Width
		t.height = msg.Height
		return t, nil

	case generateConfigsMsg:
		// Generate configs (simulated for now - just set paths)
		return t, func() tea.Msg {
			// In real implementation, this would write template files
			// For now, just signal success
			return configsGeneratedMsg{err: nil}
		}

	case configsGeneratedMsg:
		t.err = msg.err
		t.generated = true

		if t.err == nil {
			// Send settings update and completion
			settings := initpkg.InitSettings{
				ConfigX86Path:     "configs/kernel-x86_64.config",
				ConfigAarch64Path: "configs/kernel-aarch64.config",
			}

			return t, tea.Batch(
				func() tea.Msg { return SettingsUpdateMsg{Settings: settings} },
				func() tea.Msg { return TabCompleteMsg{TabIndex: 1} },
			)
		}
		return t, nil

	case spinner.TickMsg:
		if !t.generated {
			var cmd tea.Cmd
			t.spinner, cmd = t.spinner.Update(msg)
			return t, cmd
		}
	}

	return t, nil
}

// View implements tea.Model
func (t *ConfigsTab) View() string {
	theme := config.CurrentTheme

	if t.err != nil {
		return theme.ErrorStyle().Render("Error generating configs: " + t.err.Error())
	}

	if !t.generated {
		return lipgloss.JoinVertical(
			lipgloss.Left,
			"",
			t.spinner.View()+" Generating minimal kernel configurations...",
			"",
			theme.PendingIndicator()+" configs/kernel-x86_64.config",
			theme.PendingIndicator()+" configs/kernel-aarch64.config",
		)
	}

	return lipgloss.JoinVertical(
		lipgloss.Left,
		"",
		theme.SuccessMessage("Kernel configurations generated"),
		"",
		theme.CompleteIndicator()+" configs/kernel-x86_64.config",
		theme.CompleteIndicator()+" configs/kernel-aarch64.config",
	)
}

// IsComplete returns whether generation is done
func (t *ConfigsTab) IsComplete() bool {
	return t.generated && t.err == nil
}

// GetState returns tab state
func (t *ConfigsTab) GetState() ui.TabState {
	if t.err != nil {
		return ui.TabError
	}
	if t.generated {
		return ui.TabComplete
	}
	return ui.TabActive
}
```

**Step 2: Commit**

```bash
git add cmd/init/tab_configs.go
git commit -m "feat(init): add config generation tab"
```

---

## Task 6: Tab 3 - Signing Settings

**Files:**
- Create: `cmd/init/tab_signing.go`

**Step 1: Implement signing settings tab**

Create: `cmd/init/tab_signing.go`
```go
// SPDX-License-Identifier: Apache-2.0
package init

import (
	"os/exec"
	"strings"

	"github.com/charmbracelet/bubbles/spinner"
	"github.com/charmbracelet/huh"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/Work-Fort/Anvil/pkg/config"
	initpkg "github.com/Work-Fort/Anvil/pkg/init"
	"github.com/Work-Fort/Anvil/pkg/ui"
)

// SigningTab collects signing key settings
type SigningTab struct {
	width  int
	height int

	form         *huh.Form
	formComplete bool

	// Collected values
	keyName   string
	keyEmail  string
	keyExpiry string
	keyFormat string
	histFormat string

	spinner spinner.Model
}

// NewSigningTab creates a new signing settings tab
func NewSigningTab() *SigningTab {
	s := spinner.New()
	s.Spinner = spinner.Dot
	s.Style = lipgloss.NewStyle().Foreground(config.CurrentTheme.GetSecondaryColor())

	tab := &SigningTab{
		spinner: s,
	}

	tab.initForm()
	return tab
}

// initForm initializes the huh form with git config defaults
func (t *SigningTab) initForm() {
	// Try to detect git config
	gitName := getGitConfig("user.name", "ACME Kernels")
	gitEmail := getGitConfig("user.email", "releases@example.com")

	t.keyName = gitName
	t.keyEmail = gitEmail
	t.keyExpiry = "1y"
	t.keyFormat = "armored"
	t.histFormat = "armored"

	t.form = huh.NewForm(
		huh.NewGroup(
			huh.NewInput().
				Title("Key Name").
				Description("Name for the signing key").
				Value(&t.keyName).
				Validate(func(s string) error {
					if s == "" {
						return huh.ErrValidationFailed
					}
					return nil
				}),

			huh.NewInput().
				Title("Key Email").
				Description("Email for the signing key").
				Value(&t.keyEmail).
				Validate(func(s string) error {
					if s == "" || !strings.Contains(s, "@") {
						return huh.ErrValidationFailed
					}
					return nil
				}),

			huh.NewSelect[string]().
				Title("Key Expiry").
				Description("How long until the key expires").
				Options(
					huh.NewOption("1 year", "1y"),
					huh.NewOption("2 years", "2y"),
					huh.NewOption("5 years", "5y"),
					huh.NewOption("Never", "0"),
				).
				Value(&t.keyExpiry),

			huh.NewSelect[string]().
				Title("Private Key Format").
				Description("Format for storing private keys").
				Options(
					huh.NewOption("Armored (ASCII)", "armored"),
					huh.NewOption("Binary", "binary"),
				).
				Value(&t.keyFormat),

			huh.NewSelect[string]().
				Title("Public Key History Format").
				Description("Format for public key history").
				Options(
					huh.NewOption("Armored (ASCII)", "armored"),
					huh.NewOption("Binary", "binary"),
				).
				Value(&t.histFormat),
		),
	)
}

// getGitConfig gets a git config value or returns default
func getGitConfig(key, defaultValue string) string {
	cmd := exec.Command("git", "config", key)
	output, err := cmd.Output()
	if err != nil {
		return defaultValue
	}
	return strings.TrimSpace(string(output))
}

// Init implements tea.Model
func (t *SigningTab) Init() tea.Cmd {
	return tea.Batch(
		t.spinner.Tick,
		t.form.Init(),
	)
}

// Update implements tea.Model
func (t *SigningTab) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		t.width = msg.Width
		t.height = msg.Height
		return t, nil

	case spinner.TickMsg:
		if !t.formComplete {
			var cmd tea.Cmd
			t.spinner, cmd = t.spinner.Update(msg)
			return t, cmd
		}
		return t, nil
	}

	// Delegate to form
	form, cmd := t.form.Update(msg)
	if f, ok := form.(*huh.Form); ok {
		t.form = f
	}

	// Check if form completed
	if t.form.State == huh.StateCompleted && !t.formComplete {
		t.formComplete = true

		// Send settings and completion
		settings := initpkg.InitSettings{
			KeyName:       t.keyName,
			KeyEmail:      t.keyEmail,
			KeyExpiry:     t.keyExpiry,
			KeyFormat:     t.keyFormat,
			HistoryFormat: t.histFormat,
		}

		return t, tea.Batch(
			func() tea.Msg { return SettingsUpdateMsg{Settings: settings} },
			func() tea.Msg { return TabCompleteMsg{TabIndex: 2} },
		)
	}

	return t, cmd
}

// View implements tea.Model
func (t *SigningTab) View() string {
	if t.formComplete {
		theme := config.CurrentTheme
		return lipgloss.JoinVertical(
			lipgloss.Left,
			"",
			theme.SuccessMessage("Signing settings configured"),
			"",
			theme.CompleteIndicator()+" Name: "+t.keyName,
			theme.CompleteIndicator()+" Email: "+t.keyEmail,
			theme.CompleteIndicator()+" Expiry: "+t.keyExpiry,
			theme.CompleteIndicator()+" Key Format: "+t.keyFormat,
			theme.CompleteIndicator()+" History Format: "+t.histFormat,
		)
	}

	return t.form.View()
}

// IsComplete returns whether form is submitted
func (t *SigningTab) IsComplete() bool {
	return t.formComplete
}

// GetState returns tab state
func (t *SigningTab) GetState() ui.TabState {
	if t.formComplete {
		return ui.TabComplete
	}
	return ui.TabActive
}
```

**Step 2: Commit**

```bash
git add cmd/init/tab_signing.go
git commit -m "feat(init): add signing settings tab with git config detection"
```

---

## Task 7: Tab 4 - Key Generation

**Files:**
- Create: `cmd/init/tab_keygen.go`

**Step 1: Implement key generation tab**

Create: `cmd/init/tab_keygen.go`
```go
// SPDX-License-Identifier: Apache-2.0
package init

import (
	"github.com/charmbracelet/bubbles/spinner"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/Work-Fort/Anvil/pkg/config"
	initpkg "github.com/Work-Fort/Anvil/pkg/init"
	"github.com/Work-Fort/Anvil/pkg/ui"
)

// KeygenTab generates signing keys
type KeygenTab struct {
	width   int
	height  int
	spinner spinner.Model

	settings initpkg.InitSettings

	generating bool
	complete   bool
	err        error
}

// NewKeygenTab creates a new key generation tab
func NewKeygenTab() *KeygenTab {
	s := spinner.New()
	s.Spinner = spinner.Dot
	s.Style = lipgloss.NewStyle().Foreground(config.CurrentTheme.GetSecondaryColor())

	return &KeygenTab{
		spinner: s,
	}
}

// SetSettings injects signing settings from parent
func (t *KeygenTab) SetSettings(settings initpkg.InitSettings) {
	t.settings = settings
}

// Init implements tea.Model
func (t *KeygenTab) Init() tea.Cmd {
	// Start key generation
	return tea.Batch(
		t.spinner.Tick,
		t.generateKey,
	)
}

// keyGeneratedMsg signals key generation complete
type keyGeneratedMsg struct {
	keyPath       string
	publicKeyPath string
	err           error
}

// generateKey starts async key generation
func (t *KeygenTab) generateKey() tea.Msg {
	t.generating = true

	// TODO: Call pkg/signing.GenerateKey() here
	// For now, simulate success
	return keyGeneratedMsg{
		keyPath:       "keys/signing-key.asc",
		publicKeyPath: "keys/signing-key.pub.asc",
		err:           nil,
	}
}

// Update implements tea.Model
func (t *KeygenTab) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		t.width = msg.Width
		t.height = msg.Height
		return t, nil

	case keyGeneratedMsg:
		t.generating = false
		t.complete = msg.err == nil
		t.err = msg.err

		if t.complete {
			// Update settings and signal completion
			updatedSettings := t.settings
			updatedSettings.KeyGenerated = true
			updatedSettings.KeyPath = msg.keyPath
			updatedSettings.PublicKeyPath = msg.publicKeyPath

			return t, tea.Batch(
				func() tea.Msg { return SettingsUpdateMsg{Settings: updatedSettings} },
				func() tea.Msg { return TabCompleteMsg{TabIndex: 3} },
			)
		}
		return t, nil

	case spinner.TickMsg:
		if t.generating {
			var cmd tea.Cmd
			t.spinner, cmd = t.spinner.Update(msg)
			return t, cmd
		}
	}

	return t, nil
}

// View implements tea.Model
func (t *KeygenTab) View() string {
	theme := config.CurrentTheme

	if t.err != nil {
		return theme.ErrorStyle().Render("Error generating key: " + t.err.Error())
	}

	if !t.complete {
		return lipgloss.JoinVertical(
			lipgloss.Left,
			"",
			t.spinner.View()+" Generating signing key...",
			"",
			"Name: "+t.settings.KeyName,
			"Email: "+t.settings.KeyEmail,
			"Expiry: "+t.settings.KeyExpiry,
			"Format: "+t.settings.KeyFormat,
		)
	}

	return lipgloss.JoinVertical(
		lipgloss.Left,
		"",
		theme.SuccessMessage("Signing key generated"),
		"",
		theme.CompleteIndicator()+" Private key: "+t.settings.KeyPath,
		theme.CompleteIndicator()+" Public key: "+t.settings.PublicKeyPath,
		theme.CompleteIndicator()+" Encrypted: yes",
	)
}

// IsComplete returns whether key generation is done
func (t *KeygenTab) IsComplete() bool {
	return t.complete
}

// GetState returns tab state
func (t *KeygenTab) GetState() ui.TabState {
	if t.err != nil {
		return ui.TabError
	}
	if t.complete {
		return ui.TabComplete
	}
	return ui.TabActive
}
```

**Step 2: Commit**

```bash
git add cmd/init/tab_keygen.go
git commit -m "feat(init): add key generation tab"
```

---

## Task 8: Tab 5 - Summary

**Files:**
- Create: `cmd/init/tab_summary.go`

**Step 1: Implement summary tab**

Create: `cmd/init/tab_summary.go`
```go
// SPDX-License-Identifier: Apache-2.0
package init

import (
	"github.com/charmbracelet/bubbles/spinner"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/Work-Fort/Anvil/pkg/config"
	initpkg "github.com/Work-Fort/Anvil/pkg/init"
	"github.com/Work-Fort/Anvil/pkg/ui"
)

// SummaryTab shows generation results
type SummaryTab struct {
	width   int
	height  int
	spinner spinner.Model

	settings     initpkg.InitSettings
	generating   bool
	complete     bool
	filesCreated []string
	err          error
}

// NewSummaryTab creates a new summary tab
func NewSummaryTab() *SummaryTab {
	s := spinner.New()
	s.Spinner = spinner.Dot
	s.Style = lipgloss.NewStyle().Foreground(config.CurrentTheme.GetSecondaryColor())

	return &SummaryTab{
		spinner: s,
	}
}

// SetSettings injects all collected settings
func (t *SummaryTab) SetSettings(settings initpkg.InitSettings) {
	t.settings = settings
}

// Init implements tea.Model
func (t *SummaryTab) Init() tea.Cmd {
	// Start file generation
	return tea.Batch(
		t.spinner.Tick,
		t.generateFiles,
	)
}

// generateFiles starts async file generation
func (t *SummaryTab) generateFiles() tea.Msg {
	t.generating = true

	// Generate all files
	x86Tmpl := getX86ConfigTemplate()
	aarch64Tmpl := getAarch64ConfigTemplate()

	files, err := initpkg.GenerateRepoFiles(t.settings, x86Tmpl, aarch64Tmpl)

	return GenerationCompleteMsg{
		FilesCreated: files,
		Error:        err,
	}
}

// Update implements tea.Model
func (t *SummaryTab) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		t.width = msg.Width
		t.height = msg.Height
		return t, nil

	case GenerationCompleteMsg:
		t.generating = false
		t.complete = msg.Error == nil
		t.err = msg.Error
		t.filesCreated = msg.FilesCreated
		return t, nil

	case spinner.TickMsg:
		if t.generating {
			var cmd tea.Cmd
			t.spinner, cmd = t.spinner.Update(msg)
			return t, cmd
		}
	}

	return t, nil
}

// View implements tea.Model
func (t *SummaryTab) View() string {
	theme := config.CurrentTheme

	if t.err != nil {
		return theme.ErrorStyle().Render("Error: " + t.err.Error())
	}

	if !t.complete {
		return lipgloss.JoinVertical(
			lipgloss.Left,
			"",
			t.spinner.View()+" Generating repository files...",
		)
	}

	// Build file list
	fileList := []string{"", theme.SuccessMessage("Repository initialized successfully"), ""}
	for _, file := range t.filesCreated {
		fileList = append(fileList, theme.CompleteIndicator()+" "+file)
	}

	fileList = append(fileList,
		"",
		"",
		lipgloss.NewStyle().Bold(true).Render("Next Steps:"),
		"",
		"1. Customize kernel configs in configs/",
		"2. Build kernels: anvil build-kernel",
		"3. Commit to git: git add . && git commit",
		"",
		"",
		lipgloss.NewStyle().
			Foreground(theme.GetMutedColor()).
			Render("Press 'q' to exit"),
	)

	return lipgloss.JoinVertical(lipgloss.Left, fileList...)
}

// IsComplete returns whether generation is done
func (t *SummaryTab) IsComplete() bool {
	return t.complete
}

// GetState returns tab state
func (t *SummaryTab) GetState() ui.TabState {
	if t.err != nil {
		return ui.TabError
	}
	if t.complete {
		return ui.TabComplete
	}
	return ui.TabActive
}
```

**Step 2: Commit**

```bash
git add cmd/init/tab_summary.go
git commit -m "feat(init): add summary tab with file generation"
```

---

## Task 9: Parent Wizard Orchestrator

**Files:**
- Create: `cmd/init/wizard.go`

**Step 1: Implement wizard orchestrator**

Create: `cmd/init/wizard.go`
```go
// SPDX-License-Identifier: Apache-2.0
package init

import (
	"github.com/charmbracelet/bubbles/spinner"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/Work-Fort/Anvil/pkg/config"
	initpkg "github.com/Work-Fort/Anvil/pkg/init"
	"github.com/Work-Fort/Anvil/pkg/ui"
)

// WizardModel orchestrates all init tabs
type WizardModel struct {
	width  int
	height int

	tabs       []ui.Tab
	tabModels  []tea.Model
	activeTab  int
	settings   initpkg.InitSettings
	quitting   bool
	err        error
}

// NewWizardModel creates the init wizard
func NewWizardModel() WizardModel {
	// Create tab models
	tabModels := []tea.Model{
		NewWelcomeTab(),
		NewConfigsTab(),
		NewSigningTab(),
		NewKeygenTab(),
		NewSummaryTab(),
	}

	// Create tab metadata
	tabs := []ui.Tab{
		{Title: "Welcome", State: ui.TabActive},
		{Title: "Configs", State: ui.TabPending},
		{Title: "Signing", State: ui.TabPending},
		{Title: "Key Gen", State: ui.TabPending},
		{Title: "Summary", State: ui.TabPending},
	}

	// Initialize spinners for each tab
	for i := range tabs {
		s := spinner.New()
		s.Spinner = spinner.Dot
		s.Style = lipgloss.NewStyle().Foreground(config.CurrentTheme.GetSecondaryColor())
		tabs[i].Spinner = s
	}

	return WizardModel{
		tabs:      tabs,
		tabModels: tabModels,
		activeTab: 0,
	}
}

// Init implements tea.Model
func (m WizardModel) Init() tea.Cmd {
	return m.tabModels[0].Init()
}

// Update implements tea.Model
func (m WizardModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		m.width = msg.Width
		m.height = msg.Height

		// Propagate to all tabs
		var cmds []tea.Cmd
		for i := range m.tabModels {
			updatedTab, cmd := m.tabModels[i].Update(msg)
			m.tabModels[i] = updatedTab
			cmds = append(cmds, cmd)
		}
		return m, tea.Batch(cmds...)

	case tea.KeyMsg:
		if msg.String() == "q" && m.activeTab == 4 && m.tabs[4].State == ui.TabComplete {
			m.quitting = true
			return m, tea.Quit
		}

	case SettingsUpdateMsg:
		// Merge settings from tab
		m.settings = mergeSettings(m.settings, msg.Settings)
		return m, nil

	case TabCompleteMsg:
		// Mark tab as complete
		m.tabs[msg.TabIndex].State = ui.TabComplete

		// Advance to next tab
		if msg.TabIndex < len(m.tabs)-1 {
			m.activeTab = msg.TabIndex + 1
			m.tabs[m.activeTab].State = ui.TabActive

			// Inject settings into tab if needed
			switch msg.TabIndex {
			case 2: // After signing, inject settings into keygen
				if kg, ok := m.tabModels[3].(*KeygenTab); ok {
					kg.SetSettings(m.settings)
				}
			case 3: // After keygen, inject settings into summary
				if sum, ok := m.tabModels[4].(*SummaryTab); ok {
					sum.SetSettings(m.settings)
				}
			}

			return m, m.tabModels[m.activeTab].Init()
		}
		return m, nil

	case TabErrorMsg:
		m.tabs[msg.TabIndex].State = ui.TabError
		m.err = msg.Error
		return m, nil
	}

	// Delegate to active tab
	updatedTab, cmd := m.tabModels[m.activeTab].Update(msg)
	m.tabModels[m.activeTab] = updatedTab
	return m, cmd
}

// View implements tea.Model
func (m WizardModel) View() string {
	if m.width == 0 || m.height == 0 {
		return "Initializing..."
	}

	theme := config.CurrentTheme

	// Render tabs
	tabsCfg := ui.TabsConfig{
		ActiveIndex: m.activeTab,
		Width:       m.width,
	}
	tabsView := ui.RenderTabs(m.tabs, tabsCfg)

	// Render active tab content
	contentHeight := m.height - 4 // Account for tabs and padding
	content := ui.RenderTabContent(
		m.tabModels[m.activeTab].View(),
		m.width-4,
		contentHeight,
	)

	// Stack vertically
	return lipgloss.JoinVertical(
		lipgloss.Left,
		tabsView,
		content,
	)
}

// mergeSettings combines old and new settings (new overrides old)
func mergeSettings(old, new initpkg.InitSettings) initpkg.InitSettings {
	if new.ConfigX86Path != "" {
		old.ConfigX86Path = new.ConfigX86Path
	}
	if new.ConfigAarch64Path != "" {
		old.ConfigAarch64Path = new.ConfigAarch64Path
	}
	if new.KeyName != "" {
		old.KeyName = new.KeyName
	}
	if new.KeyEmail != "" {
		old.KeyEmail = new.KeyEmail
	}
	if new.KeyExpiry != "" {
		old.KeyExpiry = new.KeyExpiry
	}
	if new.KeyFormat != "" {
		old.KeyFormat = new.KeyFormat
	}
	if new.HistoryFormat != "" {
		old.HistoryFormat = new.HistoryFormat
	}
	if new.KeyGenerated {
		old.KeyGenerated = true
		old.KeyPath = new.KeyPath
		old.PublicKeyPath = new.PublicKeyPath
	}
	if len(new.FilesCreated) > 0 {
		old.FilesCreated = new.FilesCreated
	}
	return old
}
```

**Step 2: Commit**

```bash
git add cmd/init/wizard.go
git commit -m "feat(init): add wizard orchestrator with tab coordination"
```

---

## Task 10: Cobra Command & Non-Interactive Mode

**Files:**
- Create: `cmd/init/init.go`

**Step 1: Write command tests**

Create: `cmd/init/init_test.go`
```go
// SPDX-License-Identifier: Apache-2.0
package init

import (
	"os"
	"testing"
)

func TestValidateNotInitialized(t *testing.T) {
	tmpDir := t.TempDir()
	origDir, _ := os.Getwd()
	defer os.Chdir(origDir)
	os.Chdir(tmpDir)

	// Should pass when not initialized
	if err := validatePreFlight(); err != nil {
		t.Errorf("expected no error, got %v", err)
	}

	// Create config
	os.WriteFile("anvil.yaml", []byte("test"), 0644)

	// Should fail when initialized
	if err := validatePreFlight(); err == nil {
		t.Error("expected error for already initialized directory")
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./cmd/init/... -run TestValidateNotInitialized -v`
Expected: FAIL with "undefined: validatePreFlight"

**Step 3: Implement Cobra command**

Create: `cmd/init/init.go`
```go
// SPDX-License-Identifier: Apache-2.0
package init

import (
	"fmt"
	"os"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/Work-Fort/Anvil/pkg/config"
	initpkg "github.com/Work-Fort/Anvil/pkg/init"
	"github.com/spf13/cobra"
	"golang.org/x/term"
)

var (
	// Flags for non-interactive mode
	keyName      string
	keyEmail     string
	keyExpiry    string
	keyFormat    string
	histFormat   string
)

// NewInitCmd creates the init command
func NewInitCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "init",
		Short: "Initialize a kernel release repository",
		Long: `Initialize the current directory as a kernel release repository.

Creates:
  - anvil.yaml (repo configuration)
  - configs/ directory with minimal kernel templates
  - Encrypted signing keys
  - .gitignore for build artifacts

Interactive mode (default):
  Launches a wizard to collect settings and generate files.

Non-interactive mode (--key-name and --key-email required):
  Creates repository using provided flags.`,
		Example: `  # Interactive wizard
  anvil init

  # Non-interactive
  anvil init \
    --key-name "ACME Kernels" \
    --key-email "releases@acme.com" \
    --key-expiry "2y" \
    --key-format armored \
    --history-format binary`,
		RunE: runInit,
	}

	// Add flags
	cmd.Flags().StringVar(&keyName, "key-name", "", "Signing key name (required for non-interactive)")
	cmd.Flags().StringVar(&keyEmail, "key-email", "", "Signing key email (required for non-interactive)")
	cmd.Flags().StringVar(&keyExpiry, "key-expiry", "1y", "Key expiry (0, 1y, 2y, 5y)")
	cmd.Flags().StringVar(&keyFormat, "key-format", "armored", "Private key format (armored, binary)")
	cmd.Flags().StringVar(&histFormat, "history-format", "armored", "Public key history format (armored, binary)")

	return cmd
}

// runInit executes init command
func runInit(cmd *cobra.Command, args []string) error {
	// Validate pre-flight
	if err := validatePreFlight(); err != nil {
		return err
	}

	// Determine if interactive
	interactive := isInteractive() && config.GetUseTUI()

	if !interactive {
		return runNonInteractive()
	}

	// Run interactive wizard
	return runWizard()
}

// validatePreFlight checks if directory can be initialized
func validatePreFlight() error {
	// Check if already initialized
	if _, err := os.Stat("anvil.yaml"); err == nil {
		return fmt.Errorf("already initialized (anvil.yaml exists)")
	}

	// Warn if not a git repo (non-fatal)
	if _, err := os.Stat(".git"); os.IsNotExist(err) {
		fmt.Println("âš   Not a git repository - consider running 'git init' first")
	}

	return nil
}

// isInteractive checks if stdin is a terminal
func isInteractive() bool {
	return term.IsTerminal(int(os.Stdin.Fd()))
}

// runNonInteractive runs init in non-interactive mode
func runNonInteractive() error {
	// Validate required flags
	if keyName == "" || keyEmail == "" {
		return fmt.Errorf("--key-name and --key-email required in non-interactive mode")
	}

	// Build settings
	settings := initpkg.InitSettings{
		ConfigX86Path:     "configs/kernel-x86_64.config",
		ConfigAarch64Path: "configs/kernel-aarch64.config",
		KeyName:           keyName,
		KeyEmail:          keyEmail,
		KeyExpiry:         keyExpiry,
		KeyFormat:         keyFormat,
		HistoryFormat:     histFormat,
	}

	// Generate files
	x86Tmpl := getX86ConfigTemplate()
	aarch64Tmpl := getAarch64ConfigTemplate()

	files, err := initpkg.GenerateRepoFiles(settings, x86Tmpl, aarch64Tmpl)
	if err != nil {
		return err
	}

	// TODO: Generate signing key
	// For now, just print success

	// Print success
	theme := config.CurrentTheme
	fmt.Println(theme.SuccessMessage("Repository initialized successfully"))
	fmt.Println()
	for _, file := range files {
		fmt.Println(theme.CompleteIndicator() + " " + file)
	}
	fmt.Println()
	fmt.Println("Next steps:")
	fmt.Println("  1. Customize kernel configs in configs/")
	fmt.Println("  2. Build kernels: anvil build-kernel")
	fmt.Println("  3. Commit to git: git add . && git commit")

	return nil
}

// runWizard runs interactive wizard
func runWizard() error {
	p := tea.NewProgram(NewWizardModel(), tea.WithAltScreen())
	if _, err := p.Run(); err != nil {
		return fmt.Errorf("wizard failed: %w", err)
	}
	return nil
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./cmd/init/... -run TestValidateNotInitialized -v`
Expected: PASS

**Step 5: Commit**

```bash
git add cmd/init/init.go cmd/init/init_test.go
git commit -m "feat(init): add cobra command with interactive/non-interactive modes"
```

---

## Task 11: Wire to Root Command

**Files:**
- Modify: `cmd/root.go`

**Step 1: Add init command to root**

Modify: `cmd/root.go`
```go
// Add import
initCmd "github.com/Work-Fort/Anvil/cmd/init"

// In init() function, add:
rootCmd.AddCommand(initCmd.NewInitCmd())
```

**Step 2: Build and verify**

Run: `task go:build`
Expected: Build succeeds

**Step 3: Test help**

Run: `./build/anvil init --help`
Expected: Shows init command help

**Step 4: Commit**

```bash
git add cmd/root.go
git commit -m "feat(init): wire init command to root"
```

---

## Task 12: Integration Testing

**Files:**
- Test manually in `playground/`

**Step 1: Clean playground**

Run:
```bash
rm -rf playground/*
cd playground
```

**Step 2: Test non-interactive mode**

Run:
```bash
../build/anvil init \
  --key-name "Test Kernels" \
  --key-email "test@example.com" \
  --key-expiry "1y" \
  --key-format armored \
  --history-format armored
```

Expected: Success message, files created

**Step 3: Verify files created**

Run:
```bash
ls -la
cat anvil.yaml
cat .gitignore
cat configs/kernel-x86_64.config
cat configs/kernel-aarch64.config
```

Expected: All files exist with correct content

**Step 4: Verify anvil.yaml is valid**

Run:
```bash
../build/anvil config list
```

Expected: Shows config keys from anvil.yaml

**Step 5: Test already initialized**

Run:
```bash
../build/anvil init --key-name "Test" --key-email "test@example.com"
```

Expected: Error "already initialized"

**Step 6: Clean up and document success**

Run:
```bash
cd ..
rm -rf playground/*
```

**Step 7: Final commit**

```bash
git add -A
git commit -m "test(init): verify non-interactive mode in playground"
```

---

## Success Criteria

- [x] TUI wizard with 5 tabs (composable architecture)
- [x] Non-interactive mode with required flags
- [x] Minimal kernel config templates with TODO markers
- [x] Encrypted signing keys (TODO: integrate pkg/signing)
- [x] anvil.yaml with required schema keys
- [x] .gitignore excluding build artifacts
- [x] Atomic file generation with rollback on failure
- [x] Manual tests passing in playground/

## Next Steps

1. **Integrate pkg/signing.GenerateKey()** in tab_keygen.go
2. **Add TUI testing** (requires manual verification)
3. **Update documentation** when kernel config docs are ready
4. **Consider adding progress bar** if signing library reports progress

## Notes

- **@boba-master:** TUI follows Bubble Tea best practices with composable components
- **@snake-charmer:** Git config detection for smart defaults
- **@pre-alpha:** Fast iteration, no backwards compatibility needed
